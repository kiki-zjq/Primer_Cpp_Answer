# Chapter 2. 变量和基本类型 #


###2.15###

a 正确\n
b 错误，引用类型的初始值必须得是一个对象
c 正确
d 错误，引用类型必须得初始化

---

###2.16###

a 合法，d的值变为3.14159
b 合法，强制类型转换
c 合法，强制类型转换
d 合法，强制类型转换

---

###2.17###

10 10

---

###2.18###

```
int i = 10, j = 20;
int *p = &i;
p = &j; //指针p指向j
*p = 30; //指针p指向的对象j的值变成了30

```

---

###2.19###

1. 指针本身就是一个对象，允许指针之间的拷贝和赋值，也可以在其生命周期指向不同的对象。而引用不行
2. 指针无需在定义时赋值。
3. **多提一点是&这个符号既有取地址的意思，也有引用的意思**

---

###2.20###

```
int i = 42;
int *p = &i; // 指针p指向i的地址
*p = *p * *p // i的值变成42*42

```

---

###2.21###

a. 非法，类型不一致
b. 非法，没有取地址符
c. 合法

---

###2.22###

a. p是否为空指针
b. p指针所指向的值是否为0

---

###2.24###

void 定义空指针，接受任意类型的变量
而long的变量类型不是int

---

###2.25###

(a) ip 和 i 都是int类型的指针, r是int型的引用
(b) i是int型的变量，ip是空指针
(c) ip 是int类型的指针，ip2是int类型的变量

---

###2.26###

a. 不合法，变量未初始化。
b. 合法
c. 合法
d. 不合法，变量sz是一个const变量，不能被改变

---

###2.27###

a. 不合法，&r的赋值需要是一个对象
b. 合法，将p2设为一个常量指针，初始化为i2对象的地址
c. 合法，将i设为常量，r设置为常量的引用（注意const   int   &r = 0  是正确的，但是int  &r = 0是不正确的）
d. 合法，p3为指向常量的常量指针，初始值为i2的地址
e. 合法，p1为指向常量的指针，初始值为i2的地址
f. 不合法，常量得赋值
g. 合法

---

###2.28###

a. 不合法
b. 不合法
c. 不合法
d. 不合法
e. 合法 （注意，const* p是常量指针，const int *p是指向常量的指针）

---

###2.29###

a. 合法
b. 不合法，const int 和 int 不是一个类型。指向常量的指针在赋值的时候必须类型一致
c. 不合法，同b
d. 不合法，p3是一个常量指针，不能被再次赋值
e. 不合法，p2是一个常量指针，不能被再次赋值
f. 不合法，ic是个常量，不能被再次赋值

---

###2.30###

**顶层const:指的是本身不可以被改变。**
**底层const:指的是自身所指对象不可以被改变。**

v2 是顶层
p2 是底层
p3 靠左是底层，靠右是顶层

---

###2.31###

---

###2.32###

---

###2.33###

a = 42；
b = 42；
c = 42；
e:error；
f:error；
g:error；

---

###2.34###

---

###2.35###

- 第一个auto  j  类型为int
- 第二个auto  &k 类型为const int &
- 第三个auto *p类型为const int *
- 第四个auto j2类型为const int 
- 第五个auto &k2 类型为const int&

---

###2.36###

- a是int类型   4
- b是int类型   4
- c是int类型   4
- d是int &类型    4

---

###2.37###

- a是int类型   3
- b是int类型   4
- c是int类型   3
- d是int &类型    3

---

###2.38###

主要的区别有两点：
1：如果使用引用类型，auto会识别为其所指对象的类型，decltype则会识别为引用的类型。
2：decltype(())双括号的差别。

```
int i = 0, &r = i;
// same
auto a = i;
decltype(i) b = i;
// different
auto c = r;
decltype(r) d = i;
```

---

###2.39###

